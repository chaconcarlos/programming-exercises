Docker
======
* Environments
  - On Mac OS / Windows -> Docker Desktop
  - Linux: Docker engine supported natively.
* Tools
  - Docker Engine
  - Docker Desktop
  - Docker Hub
  - Docker Composer
  - Kubernetes

COMMANDS
========
* docker run [IMAGE_NAME] -> will pull the image and run a container with that image.
  -p [LOCAL_PORT:CONTAINER_PORT] -> exposes the container port as the local port indicated.
  -d -> run in detached mode.
  -i -> enables interactive mode. Keeps STDIN open. Usually combined with -t.
  -t -> allocates a pseudo TTY.
  -v [VOLUME_NAME]:[CONTAINER_PATH] -> creates a named volume in the given host path.
  -v [HOST_PATH]:[CONTAINER_PATH] -> creates a bind mount.
  --rm -> automatically remove the container when it finishes or is stopped.
  --name [CONTAINER_NAME] -> adds a name to the container.
* docker container attach [CONTAINER_NAME] -> attachs to a container.
* docker logs [CONTAINER_NAME] -> check the messages logged by a container without attaching.
  -f -> enables follow mode, which will continue to update.
* docker ps -> List of containers that are running.
  -a List all containers, even the ones that are not running.
* docker build [DOCKERFILE_PATH] -> builds a custom image based on a Dockerfile
  -t [name]:[tag] -> assigns a tag to the image.
* docker start [CONTAINER_NAME] -> restarts a container. With this command, the container will run in the background (detached mode).
  -a -> enables attach mode.
  -i -> enables interactive mode. Keeps STDIN open. Usually combined with -t.
  - start vs run: run creates a container. start restarts an already created container.
* docker stop [CONTAINER_NAME] -> stops a container.
* docker rm [CONTAINER_NAME] -> removes a container. Should be stopped before removing.
* docker images -> list images created.
* docker rmi [IMAGE_NAME] (*) -> removes an image. No containers should be using the image.
* docker image prune -> removes all unused images.
* docker image inspect [IMAGE_NAME] -> shows the whole configuration for the image.
* docker tag [OLD_IMAGE_NAME] [NEW_IMAGE_NAME] -> retags an image. When renaming an image, it creates a clone, doesn't rename perse.
* docker cp [SOURCE_PATH][/.] [CONTAINER_NAME]:[CONTAINER_TARGET_PATH] -> copy files to a container.
  - docker cp [CONTAINER_NAME]:[CONTAINER_TARGET_PATH] [SOURCE_PATH] -> copy files from a container.

IMAGES
======
* Usually, we download images and build images based on those.
* An image is read-only once is created.
  - Changes can only be done by rebuilding.
* When rebuilding an image, if there's no changes in the instructions, it will use a cache to rebuild faster.
  - Layer-based architecture.
* docker build [DOCKERFILE_PATH] -> builds a custom image based on a Dockerfile
* Image tags -> name:tag. For example, node:14

SHARING IMAGES
==============
* Two ways:
  - Share Dockerfile: needs everything outside of the image, and build the image.
  - Share the image: just create a container and run. No build required.
* Images can be pushed to:
  - Docker Hub: official image repository.
  - Private registry. Artifactory?
* Share: docker push [HOST]:[IMAGE_NAME]:[TAG]
  - if no tag is given, it sets it as latest.
* Use: docker pull [HOST]:[IMAGE_NAME]
* If no host is given, uses Docker Hub.
* Log to the repository: docker login

VOLUMES
=======
* Volumes: managed by docker. 
  - Anonymous volumes:
    - Only can access through docker volume.
    - Volumes only exists while the container exists.
    - If new containers are created, an new anonymous volume is created.
    - To clear them: docker volume rm VOL_NAME or docker volume prune
  - Named volumes
    - Exists after the container is stopped / removed.
* Volumes are great for data that should be persistent but doesn't need to be edited.

BIND MOUNTS
===========
* Managed by the user.
* User defines the folder / path on the host machine.
* Ideal for persistent and editable data.
* Is not done from the Dockerfile. 
* The folders should be registered as resources on Docker to be acccessible.